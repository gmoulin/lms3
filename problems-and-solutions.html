---
layout: default
title: Problems and solutions found along the way
---
<div class="intro">
	<p>
		You will find listed on this page the main problems I ran into during the different phases of the LMS3 project.<br />
		By main problems I mean those which took me several trys and some time to fix.<br />
		Each problem have a description, an analysis and a solution; this to show how I resolved it.<br />
	</p>
</div>

<!-- Documentation -->
<div class="doc-section">
	<div class="page-header">
		<h1 id="documentation">Documentation:</h1>
	</div>

	<!-- sidenav maintenance -->
	<h3 id="sidenav-maintenance">Sidenav maintenance</h3>
	<p>
		Bootstrap sidenav combined with scrollspy is really good for documentation purpose but the maintenance is awfull, time for automation.<br />
		This solution is not optimal since it occurs on load and force a repaint but the gain in maintenance ease is worth it.<br />
		{% highlight javascript %}
var $body = $(document.body),
	$head = $(document.head),
	$navSidebar = $('.nav-sidebar');

if( $navSidebar.find('.nav-sidenav').find('li').length === 0 ){
	var sidenav = "",
		hasSub = false;
	$('.content').find('.doc-section').each(function(){
		$(this).find('h1, h3').each(function(){
			var $anchor = $(this);
			if( $anchor.is('h3') ){
				if( !hasSub ){
					hasSub = true;
					sidenav += '<ul class="nav">';
				}
			} else {
				if( hasSub ){
					hasSub = false;
					sidenav += '</ul>';
				}
				if( sidenav.length > 0 ){
					sidenav += '</li>';
				}
			}

			sidenav += '<li><a href="#'+ this.id +'">'+ $anchor.text().replace(':', '') +'</a>';
			if( $anchor.is('h3') ){
				sidenav += '</li>';
			}
		});
	});

	$navSidebar.find('.nav-sidenav').html( sidenav );
}
		{% endhighlight %}
	</p>
	<!--/sidenav maintenance -->

	<!-- livereload support -->
	<h3 id="jekyll-with-livereload-support">Jekyll with livereload support</h3>
	<p>
		Jekyll has a watch feature but no livereload support, clearly need some <a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank">grunt-contrib-watch</a> love.<br />
		Easier said than done, as <code>jekyll serve</code> is a process that grunt can not interrupt.<br />
		So grunt will only rebuild the site and fire the livereload event. Both <code>jekyll serve</code> and watch tasks are living process, so <a href="https://github.com/sindresorhus/grunt-concurrent" target="_blank">grunt-concurrent</a> is needed.<br />

		<br />
		Now I just need a terminal window, go to project gh_pages directory and run <code>grunt</code>, then open my browser, navigate to http://localhost:4000/ and enable livereload extension.<br />

		<br />
		No more need to press refresh when I update the documentation.<br />

		<br />
		Here is the final Gruntfile code.<br />

		{% highlight javascript %}
'use strict';

var LIVERELOAD_PORT = 35729; //port of chrome livereload extension

module.exports = function( grunt ){
	// load all grunt tasks using the package.json dependencies list
	require('matchdep').filterDev('grunt-*').forEach( grunt.loadNpmTasks );

	grunt.initConfig({
		concurrent: {
			target: {
				tasks: ['watch', 'shell:jekyllServe'],
				options: {
					logConcurrentOutput: true
				}
			}
		},

		watch: {
			jekyll: {
				files: [
					'_includes/*.html',
					'_layouts/*.html',
					'index.html',
					'grunt-workflow.html',
					'problems-and-solutions.html'
				],
				tasks: ['shell:jekyllBuild'],
				options: {
					livereload: LIVERELOAD_PORT,
					atBegin: true //will run jekyllBuild when watch start
				}
			}
		},

		shell: {
			options: {
				stdout: true
			},
			jekyllBuild: {
				command: "jekyll build --baseurl ''" //_config.yml has already a baseurl for github.io, replace it for local preview
			},
			jekyllServe: {
				command: "jekyll serve --baseurl ''"
			}
		}
	});

	grunt.registerTask('default', ['concurrent']);
};
		{% endhighlight %}
	</p>
	<!--/livereload support -->
</div>
<!--/Documentation -->

<!-- Node -->
<div class="doc-section">
	<div class="page-header">
		<h1 id="node">Node:</h1>
	</div>

	<!-- full domain support -->
	<h3 id="full-domain-support">Full domain support</h3>
	<p>
		Using the apache proxy directive to redirect request to a localhost port.<br />
		{% highlight apache %}
<VirtualHost *:80>
    ServerName  www.lms3.dev
    ServerAlias lms3.dev

    ProxyRequests off
    <Proxy *>
        Order deny,allow
        Allow from all
    </Proxy>
    <Location />
        ProxyPass http://localhost:3001/
        ProxyPassReverse http://localhost:3001/
    </Location>
</VirtualHost>

<VirtualHost *:80>
    ServerName  www.lms3.qual
    ServerAlias lms3.qual

    ProxyRequests off
    <Proxy *>
        Order deny,allow
        Allow from all
    </Proxy>
    <Location />
        ProxyPass http://localhost:3002/
        ProxyPassReverse http://localhost:3002/
    </Location>
</VirtualHost>

<VirtualHost *:80>
    ServerName  www.lms3.prod
    ServerAlias lms3.prod

    ProxyRequests off
    <Proxy *>
        Order deny,allow
        Allow from all
    </Proxy>
    <Location />
        ProxyPass http://localhost:3003/
        ProxyPassReverse http://localhost:3003/
    </Location>
</VirtualHost>
		{% endhighlight %}
	</p>
	<!--/full domain support -->
</div>
<!--/Node -->

<!-- Angular unit test -->
<div class="doc-section">
	<div class="page-header">
		<h1 id="angular-unit-test">Angular Unit Test:</h1>
	</div>
	<!-- controller with filter -->
	<h3 id="controller-with-filter">Controller with filter</h3>
	<p>
		My home controller is using a filter, I had some problems finding the correct way to test it.<br />
		{% highlight javascript %}
angular
	.module('lms.controllers')
	.controller('home', [
		'$scope',
		'groupFilter',
		function( $scope, groupFilter ){
			//...
		}
	])
;
		{% endhighlight %}
		<br />
		First both modules need to be mocked for the correct variables name to be available, using <code>module</code> function from angular-mock.<br />
		{% highlight javascript %}
beforeEach(function(){
	module('lms.controllers');
	module('lms.filters');
});
		{% endhighlight %}
		<br />
		Then the filter will be passed to the test using the <code>inject</code> function.<br />
		The controller also need the filter (per definition).<br />
		{% highlight javascript %}
it('should have parts and groups populated', inject(function( $controller, $rootScope, groupFilter ){
	var scope = $rootScope.$new()
		, ctrl = $controller('home', {$scope: scope, groupFilter: groupFilter})
	;

	//expect ...
}) );
		{% endhighlight %}
	</p>
	<!--/controller with filter -->

	<!-- controller using ajax -->
	<h3 id="controller-using-ajax">Controller using ajax</h3>
	<p>
		My book controller is using my CRUD service, I had some problems finding the correct way to test it.<br />
		{% highlight javascript %}
angular
	.module('lms.controllers')
	.controller('books', [
		'$scope',
		'crud',
		function( $scope, crud ){
			//...
		}
	])
;
		{% endhighlight %}
		<br />
		First both modules need to be mocked for the correct variables name to be available, using <code>module</code> function from angular-mock.<br />
		{% highlight javascript %}
beforeEach(function(){
	module('lms.controllers');
	module('lms.services');
});
		{% endhighlight %}
		<br />
		Second the ajax mock need to be initialized and checked for each tests.<br />
		{% highlight javascript %}
beforeEach( inject(function( $injector ){
	$httpBackend = $injector.get('$httpBackend');
}) );

afterEach(function() {
	$httpBackend.verifyNoOutstandingExpectation();
	$httpBackend.verifyNoOutstandingRequest();
});
		{% endhighlight %}
		<br />
		Then the service will be passed to the test using the <code>inject</code> function.<br />
		The controller also need the service (per definition).<br />
		The ajax mock is setted and warn of a forecoming request.<br />
		The <code>$httpBackend.flush()</code> is needed for the controller to receive the response.</br >
		{% highlight javascript %}
it('should get all books', inject(function( $controller, $rootScope, crud ){
	$httpBackend.whenGET('/rest/books').respond([ {id: 1}, {id: 2} ]);

	$httpBackend.expectGET('/rest/books');

	var scope = $rootScope.$new()
		, ctrl = $controller('books', {$scope: scope, crud: crud})
	;

	$httpBackend.flush();

	//expect ...
}) );
		{% endhighlight %}
	</p>
	<!--/controller using ajax -->
</div>
<!--/Angular unit test -->
